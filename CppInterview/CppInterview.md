# 1. C++面向对象三大特性:继承\封装\多态

**(1) 封装性：** 将客观事物抽象成类，把复杂的细节封装在内部，仅提供简单的接口即可,封装可以隐藏实现细节，使得代码模块化,保护或者防止数据被无意破坏。每个类自身的数据和方法实现权限控制，只让可信的类或者对象操作,对不可信的类进行信息隐藏；

**(2) 继承性:** 继承可以使得子类具有父类的各种属性和方法,无需重新编写；

**(3) 多态性：** 多态是指不同对象接收相同消息时产生不同的动作,通过基类的指针或者引用,在运行时动态调用实际绑定对象函数的行为。在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。



# 2.类的访问与继承权限

- **类的访问:**

**(1) public:** 用该关键字修饰的成员表示<u>公有成员</u>，该成员不仅可以在类内可以被访问，在类外也是可以被访问的,是类对外提供的可访问接口；

**(2) private:** 用该关键字修饰的成员表示<u>私有成员</u>，该成员仅在类内可以被访问,在类体外是隐藏状态；

**(3) protected:** 用该关键字修饰的成员表示<u>保护成员</u>，保护成员在类体外同样是隐藏状态，但是对于该类的<u>派生类</u>来说,相当于<u>公有成员</u>,在派生类中可以被访问。

- **类的继承:**

**(1) 继承方式public:** 基类成员在派生类中的访问权限保持不变；

**(2) 继承方式private:** 基类所有成员在派生类中的访问权限都会变为私有(private)权限；

**(3) 继承方式protected:** 基类的公有成员和保护成员在派生类中的访问权限都会变为保护权限，私有成员在派生类中的访问权限仍然是私有权限。

- **构造和析构:**

构造函数和析构函数无法被继承，在整个层次中的所有的构造函数和析构函数都必须被调用。子类的构造函数会显示的调用父类的构造函数或隐式的调用父类的默认的构造函数进行父类部分的初始化。


# 3. C++程序的内存分区 

- **分区:**

**(1) 栈区(stack):** 由编译器自动分配和释放，存放函数的形参，局部变量等；

**(2) 堆区(heap):** 一般由程序员释放(动态内存申请与释放)，如果程序员没有进行释放，程序结束由OS统一回收；

**(3) 全局区\静态区(static:** 用于存放全局变量和静态变量，分为两部分，初始化的放置.data段，没有初始化的放在.bss段，没有初始化的全局变量会初始化为0，静态成员变量在初始化前没有进行内存分配；

**(4) 代码区:** 存放代码。

- **堆栈区别:**

**(1)管理方式:** 堆由用户手动申请手动释放，容易产生内存泄露；栈由系统自由分配自动回收。

**(2)生长方式:** 对自下而上，栈自上而下。

**(3)碎片:** 堆中内存分配和释放会产生内存碎片，栈采用后进先出的机制，不会产生碎片。


# 4. C++编译过程
编译流程分为四个阶段:<u>预处理</u> <u>编译</u> <u>汇编</u> <u>链接</u>

**(1)预处理:** 处理一些#定义的命令或语句(如`#define #include #ifdef`)，生成.i文件；

**(2)编译:** 进行语法分析等，生成.s的汇编文件；

**(3)汇编:** 将对应的汇编指令翻译成机器指令，生成.o目标文件；

**(4)链接:** 动态链接或静态链接，将多个目标文件以及所需要的库链接成最终的生成可执行文件。


# 5. C++泛型编程
- 主要通过模板实现，包括<u>函数模板</u>和<u>类模板</u>。

**(1)函数模板:** 以`template`关键字开始，形参由关键字`class`或`typename`构成如下，

```c++
template<typename T>
int add(const T &v1, const T &v2) {
    return v1 + v2;
}
```

**(2)类模板:** 以`template`关键字开始，在调用时需要为模板形参显示指定形参，

```c++
template<typename Type>
class Queue {
public:
    Queue();  
    Type & front();
    const Type & front() const;
    void push(const Type &);
    void pop();
    bool empty() const;
private:
    // …
};

// 调用
Queue<int> test_int;
Queue<double> test_double;
```

**typename和class区别与联系:**  当表示模板参数时，二者没有区别；当模板函数内部的成员表示一个类型时(标识嵌套从属类型名称)，必须使用`typename`，如果不使用`typename`编译器会把从属嵌套的类型视为一个成员变量，在遇到\*时，会把\*解析成乘法，而不是解引用符号。如下

```c++
template <class T>
class MyTest {
    public:
	class T::val_type func(const T &c);
};

template <class T>
class T::val_type MyTest<T>::func(const T &c) {
	typename T::val_type *ptr;  // 必须使用typename
    class T::val_type t;
	return typename T::val_type();
}
```



# 6. C++编译器自动为类产生的缺省函数

- [ ] 未完成


# 7. const关键字

- [ ] 未完成


# 8. static关键字

- [ ] 未完成